
=head1 NAME

Template::Averse - Another Variable Extract Replace Substitute Environment


=head1 DOCUMENTS TO READ

=item perldoc Template::Averse

This file.  An introduction, plus details and examples at the end.

=item perldoc Template::Averse::Parser

Synopsis for non-XML templates.  The examples at the end of this
also illustrate the usage.

=item perldoc Template::Averse::SAXHandler

Synopsis for XML templates.
The examples at the end of this
also illustrate the usage.

=head1 SYNOPSIS/METHODS

Please read the above mentioned documents for these.



=head1 DESCRIPTION

An Averse template consists of three things.

1. A file called the "template body" which contains regions of text
called "components".  

2. A data structure called the "component definitions" which indicates
what regions to recognize as components, and how to map them to perl subs.

3. And a set of perl subs called "callbacks", that are provided by the
programmer, which implement any logic and variable substitution for the
template.

Each component uses two (or more related) functions.  One function is
generated by the Averse compiler.  The other function is called the
"callback", and is created by the programmer.  The callback has easy
access to its associated generated template function(s).  It calls them in
what ever manner will implement the visual logic of the component, and
then returns all the values it receives to its caller.  (If the callback
is implementing a variable then it can simply return the desired value in
the desired format instead of invoking any other function).  Depending on
how the template is setup, the callback may also be responsible for
passing variable data into the template.


=head1 COMPONENTS

The body of the template contains regions, possibly nested, called
"components".  To use a component, the parser must be able to find it. 

There are two ways to identify the components.  XML or "markers".

XML is mush easier to use.  The only question is to identify which tagged
regions are the ones the template wishes to use as components.

The other technique is to use markers.  Markers are regular expressions
that are used to find the edges and midpoints of the components.  Said
again, the regular expressions do not identify the complete component,
they identify the _edges_ of the components, or specific points inside the
component (called middles).


=head1 DEFINING COMPONENTS

Component definitions are stored in a hash.  The name of the hash does not
matter.  What is required is a reference to the hash.  

The hash can be  usefully  stored  in a separate file, and "require" used
to load the hash into memory and return the required reference to the
hash.

The following is a minimal set of two component definitions.  (This set of
definitions is intended for Averse parsing, not XML, but the overall
arrangement and usage is the same.)


    # COMPONENT-DEFINITIONS.PL

    %two_components = 
    (
        one => { start=>'(?m)^ONE.*'},  # (?m)^ONE.* is a MARKER
        two => { start=>'(?m)^TWO.*'},  # and is discussed below 
    );
    \%two_components; # for require, this is the last line


    # A-FILE-THAT-USES-THE-COMPONENTS

    my $components = require 'COMPONENT-DEFINITIONS.PL';



Each key in the component definition hash is the name of a component.  In
the above example they are `one' and `two'.  The name gets mapped to a
subroutine name, therefore the name must be useable as a subroutine name.

Each value is itself a hash reference.  The keys and values of that hash
define the details of that component.  In the above example, each
definition includes a single item, `start', and the regular expression
(called a "marker") that is used to find the corresponding marker in the
body of the template.

The components will eventually form a hierachy.  One component must be at
the top.  The default name of the topmost component is `Template'.  You do
not need to provide a component with this name.  If you do provide a
component called `Template' then its definition it used, otherwise default
values are used.

When you create a parser then you can specify a different top level
component.

=head1 COMPONENT DEFINITIONS PARAMETER - name space only

Not ready yet.

For XML usage only, the xml name space of the tags to be handled would be 
specified.  Any tag in that name space would map to a like-named function
in the template.

=head1 COMPONENT DEFINITIONS PARAMETER - tag names only

For XML usage only, the component definitions may be simply a list of the
tag names to be handled.  In that case, the component definition hash
discussed about is created automatically using default values.


=head1 COMPONENT DEFINITIONS PARAMETER - full definitions

A full set of component definitions is passed as a hash reference, as
mentioned above.

Each key of the hash becomes a component name.  The name must be a valid
perl sub name.

The same component definitions can be used for both xml and non-xml
templates, assuming the necessary items are included.  In this case, some
care may be needed if the `syntax' item is specified, and xml child
components may conflict (if so that will be fixed later).

There are three kinds of component definitions.

-1- Regular components.

A regular component contains all the details for itself and any children
or middles.

Children may be used within xml, middles may be used for non-xml parsing.

If a component has children then it is a parent, but it does not identify
itself as such, instead it is the children who indicate they are children
by referencing the parent.

A regular component maps to a single callback function.

-2- Child components.

These are only for XML usage.  Non-XML usage uses middle markers which are
defined within the parent definition. 

A child component is a component that indicates it has a parent.  The
parent must be a regular component, not itself a child.  I.e.  children
components can be nested to one level deep.  

Some compile options for the child are taken from the parent's definition,
not from the child.

Unlike regular component, a child component does _not_ map to a callback
function.  Instead the parent callback will be expected to invoke the
child as part of implementing the logic of the parent.  

The one level deep nesting referred to above is of course just for the
child/parent callback logic.  Components within a template body may be
nested to any depth you wish.

-3- The top level component.

The top level component is hardly different than a regular component.  

The top level component is always created, whether or not a corresponding
tagged region is found in the template body.  

If no top level component is specified, then one is created with the name
Template::Template.  

The top level component is specified by passing its name when the handler
is created.  If the specified component has no definition then default
settings are used.

In xml, if the top level tag is mapped to a component then there are
effectively two top level components for the template.  The one that
corresponds to the xml tag, and the one that is created specially to
contain the template.  Either of the two could be used to invoke the
entire template at run time.


=head2 COMPONENT DEFINITION ITEMS

=over 4

=item enable, start, middle, end

These are for non-XML usage, and are explained fully further down.

=item vars 

optional - an array reference, the values are strings

The names of variables to include in that scope of the template code.
These variables can be passed to the template when the component is
invoked, the order must be the order shown in the vars item.  If an array
or hash is to be passed then either it must be the last item in the list,
or you must pass it by reference.


=item {child}_vars, {middle}_vars

optional - an array reference, the values are strings

Note: (in XML) the child's vars item is contained in the parent's component
definition.

For either {child} or {middle}, replace that word with the name assigned
to that portion of the component.

These must be a subset of the parent variables.  

These variables can be passed to the template when the child component is
invoked.  When doing so, the order in which they are passed must be the
order shown in the child_vars item, though this order can be different
than the order specified for the parent vars.

=item options

optional - a hash reference, keys are the keywords listed below

=over 4

=item PerlInterpolate

optional

For this component's code, the strings should be included directly in the
body of the created sub, with the quoting necessary to allow perl to
interpolate any variables.

Value should be true to enable, false otherwise.

=item PerlInline

optional

For this component's code, the strings should be scanned for {+ and +} to
allow perl code to be embedded inline within the code.

This value is always true for now, and there is not yet a correspnding
option to define what demarkers should be used.

=back 4

=item package

optional - a string

The package name for the generated sub code.  The default for a regular
component is the name of the component.  The default for a child component
is the package name of the parent.  

(Setting this for a child may have no effect, the child probably always
uses the parent's package - either the default or that specified for the
parent, I'm not sure as I write this.)

There is not yet an option for the callback package.  For now it is always
"Callback::"

=item keep 

optional - the value should be true or false - for XML only.

The text for the tag will be kept as part of the component. 

=item replace

optional - an array reference, the values are strings

This is a list of pairs of strings which become the parameters of an s///g
statement (one s///g per pair).  The s///g statements are run over all the
substrings within the scope of the component (including the text of
components nested within this component).  This takes place after the xml
has been parsed, but before any perl code is inlined.  Among other things,
this allows inline perl code to be inserted into places where the syntax
of the xml might not otherwise it to be inserted.

=item syntax 

optional - a string which is a regular expression

Intended for non-XML usage only.

This string indicates the allowed sequence of the names of the start
middle and end markers for this component.  

The syntax string is a perl regular expression.  It is used as follows.
As each marker is found, the name of the marker is placed into a string
with a single space between each of the names.  When the end of the
component is found then the string just described is matched against the
syntax string.  

(In truth, the syntax string is munged slightly in use to make it simpler
and clearer to specify.  Spaces in the syntax string are converted to
\s*\b.)

The following is a typical string that might be generated by the parser as
the markers for a component are discovered.

"start case1 case2 end"

Consider the following syntax string.  It indicates that any number of the
middle markers can be used, as long as they occur in pairs in the correct
order.  It would validate the above component.

syntax=>"start (case1 case2)* end"

Now consider an alternate syntax string.  The following syntax would check
that all three middles were used at least once.  It would raise an error
if the above component had been found (because middle "case3" had not been
used).

syntax=>"start (case1 case2 case3)+ end"



=item parent

optional - a string - for XML only.

The name of the parent component if this is a child.  The name is the
component name, not the tag name (i.e. it is the same as a top level key
in the component definitions hash).

=item NamespaceURI

optional - a string - for XML only.

If xml name spaces are used then the tag found may have a NamespaceURI
associated with it.  In that case the component definition must include
the name space URI for it to match the tag.

=item LocalName   

optional - a string - for XML only.

By default, the local name of the tag is the same as the component name.
This item may be used to provide a different mapping.  In particular, if
the local name of the xml tag is not a valid perl identifier then you can
not use it directly as a component name, and have to provide a
translation.

=head1 NON-XML COMPONENTS

The body of the template contains regions called "components".  To use a
component, the parser must be able to find it.  What we find are strings
within the body of the template that are at the edges of the component, or
at other important locations in the middle of the component.  

Those locations are identified using regular expressions referred to as
"markers".

The markers are given names.

The names are `enable', `start', `middle', and `end'.  A middle marker can
have other names when in use, but for now we'll just use the name
"middle".


Each component has the following schematic description within the body of
a template.

    (enable)* start (middles* end)?

I.e.  the start marker  always  occurs.    There  can  be  at most one end
marker.  There can be any number  of middles, which must occur between the
start and the end, and there can be  any number of enables, and they occur
before the start.

Components may nest.

    start1 component2 middle1 component3 end1

The enable markers are seperate from the nesting of the components and can
occur anywhere before the component to which they are attached.



=head2 MARKERS


To find the "edges" of  a component we use a regular expression called a
"marker".  The marker may contain a single set of capturing brackets.  The
example given at the top does not contain any capturing brackets.  (The
(?m) is not a capturing bracket.) If used, capturing brackets must occur
at the start of the marker.  The length of text captured by the brackets
is skipped when determining the portion of the template body that is found
by the regular expression.

The length of text in the body of the template that is supposed to be
found by a marker is also called a marker.  In practise this dual usage is
rarely ambiguous.

Note: "required" below means required for non-XML usage.

=item enable - optional - a string which is a marker

This marker indicates to the parser that it (the parser) should be ready
to recognize an incidence of this component.  This marker does not
translate to any code.

=item start - required - a string which is a marker

This marker indicates the start of this component. If the component does
not have an end marker then the component occurs at the location of the
start marker (i.e. the end occurs at the offset that just follows the
start).

=item middle - optional - one or more markers

The possible values are given in detail below.

The middle markers break the component into multiple pieces.

=item end - optional - a string which is a marker

This marker indicates the end of this component. The end marker is
required if the component definition has any middle markers.

The absence of the end marker from the definition implicitly indicates the
component has no length.

=head2 MIDDLES

To define a single middle point with the default name of "middle", simply
indicate the marker to use.

 MyTag => { start  => 'start-marker' ,
            middle => 'middle-marker',
            end    => 'end-marker' ,
          }


Multiple middles can be defined.  If there is a single marker to identify
each middle, then you can use a hash (reference), where each middle name
is the key.

 MyTag => { start  => 'start-marker' ,
            middle => { 'part-1' => 'part1-marker' ,
                        'part-2' => 'part2-marker' ,
                      } ,
            end    => 'end-marker' ,
          }


If there is more than one marker used to identify a middle, then use an
array (reference), in which the names and the markers alternate.

 MyTag => { start  => 'start-marker' ,
            middle => [ 'part-1' => 'part1-marker' ,
                        'part-1' => 'alternate-part1-marker' ,
                        'part-2' => 'part2-marker' ,
                      ] ,
            end    => 'end-marker' ,
          }




=head1 CALLBACKS

Callbacks must be defined in the "Callback::" package.  The package name
is not yet an option.

The callback name is the component name from the component definition
(discussed below).

The corresponding component sub is available by name within the callback.
The name is the package specified for the component in question, and the
component name.  The default package is the component name.

For XML, the component may have children.  For non-XML usage the component
may have middles.  The only difference is that each child always generates
an additional implicit end_childname sub corresponding to the text that
follows the child, whereas a middle does not need this as the end is
either the next middle or end of the component.

Both children and middles are available using their own name, in the same
package as the component.

Also, for components with more than one part, one extra sub is defined,
called end_name, which is an alternate name for which ever part is last.

The first parameter passed to the callback sub is a reference to a hash
which contains context information.

The context includes the original text of the tag that caused this
incidence of the component to be generated (in XML this is actually the
text as reproduced after being parsed).

For XML, the context also includes the parsed attributes that were
associated with the parent tag of the component.

The key in the context hash to access the original text of the tag is the
address of the sub.  The primary context value can be found using the name
of the sub (which is always known).  I.e. the primary context value wanted
within Callback::Tr would be associated with "sub Tr::Tr", which can be
found using $context{\&Tr::Tr}. (assuming the context is access using that
name.

Attributes are accessed using the key name `Attributes'.

Variables are accessed using the key name `Vars'.

The variables defined using the `vars' items of the components, and which
are in scope at that point in the template, are accessible from the
context using the key name `Vars'.  This is a hash that maps the var name
to a reference of that variable.  This allows a callback to see variables
set in a container component.  Using the Vars to allow a callback to set
values into its container's variables is probably a nasty thing to do.
The only reason the template does not prevent this by providing just the
values is that references can be set just once when the template loads.


The context also includes the keys '-parent' and '-children' which provide
a reference and an array of references to the parent and children contexts
respectively.  (No methods are provided to traverse the resulting trees.)

The context is retained from invocation to invocation of each instance of
a component.  Therefore you could add additional data to the context if
you wish and it will be available each time that instance of the component
is invoked.  HOWEVER - this may clash with mod_perl usage, as there is no
way to reset the context except by reloading the template.  Therefore, you
might be better off using some other technique.  On possibility is to use
the context as a key into your own data structure.  (It will be
stringified, but is unique, so given a template context, you could also
obtain your saved context data.)

Subsequent parameters passed to the callback function are a list of
component or child component names, and the address of the associated sub.

You can loop through the list to access all the different children in the
order they occured in the original template body.  This would be required
if the same child appeared multiple times, as in that case the plain child
component name is ambiguous and only accesses the last instance of each
child within that component.  This would also be required if the order of
the children was relevant to the logic of the component.

=head1 VISUAL SUBROUTINES

A component can be used to built a "visual subroutine" as follows.

Notice that the first instance of a component is always assigned the
expected name.  Therefore the first instance can easily be invoked by any
other code, by its name, and this allows a single instance of a component
to be easily used in multiple locations within the template.

The callback for that component should (normally) return an empty list at
run time.

Other components can be inserted at the desired location of the expanded
visual subroutine.  Each of those will invoke its own callback at run
time.  That callback can then call the original component directly by
name.

Examples are included at the end of this document that shows this
technique.

=head1 IMPLEMENTING TEMPLATE VARIABLES

=head2 CALLBACK VARIABLES

Variables may be implemented as components using callbacks.  

In this case, the easiest way to correctly implement variable scoping is
to use local($VAR_NAME) in the callback of the container component of the
variable.  An example is included at the end of this document that shows
a general purpose tag that does this.

You can also examine the context tree of the component to implement other
types of scoping based on the lexical template structure.  No example is
given for this.


=head2 INLINE VARIABLES

Another solution is to allow perl code to be embedded inline in the
template.  The code is used as part of a return() statement, so the code
is _not_ free to do anything it wishes.  However, the intended use is for
accessing variables or other items that return values, for which this
works very well.  In this case perl itself takes care of the natural
scoping of variables within the template.  The code is run in array
context, unless a callback does something unusual to prevent this.

Perl code is inserted inline using the notation {+perl_code+} .  I.E. the
perl code is demarked with braces and plus signs around the code.

AN EXAMPLE (this would occur in a template body)

    blah blah {+ $variable +} yada yada

There is no option to change the syntax (yet).

These types of variables are always available by simply using the above
syntax, though a later version of Averse may require an option be set to
allow this.  If C<use strict;> is in force then the variables will need to
be in scope (the intended behaviour).

A component's definition can be used to define which variables will be
defined for that portion of the template.  For simple templates you can
define the variables ahead of the template code block so a single set of
variables is in scope for the entire template.  Otherwise look for the
vars item mentioned above.

The variables that are in scope are accessible to the callback via the
{Vars} key of the context parameter.  An example shows this usage.


=head2 INTERPOLATED VARIABLES

You may also request perl interpolation of variables.  This is enabled
on a component by component basis, as described in the component
definition section.

In this case the generated text of the template includes code such
as the following.

    return (qq{this $variable was in the template});

Therefore, the data returned by the template will included variables
interpolated by the normal perl mechanisms.

Note: the quoting is not necessarily qq{}.  The template chooses a
quoting that will not conflict, or warns you if it can't do that.


=head1 EXAMPLES

Most of the examples are included in the distribution, even when the
example does not make mention of this.


=head1 SIMPLE XML TEMPLATE LOOP with perl variables

This example uses perl variables within a simple loop.

This example is available with the distribution in the files

    eg1-defns  eg1-pl  eg1-xml

To create and run the compiled template, run the following commands inside
the top level directory of the distribution.

    $ perl averse-tcxml eg1-defns eg1-xml > eg1.do
    $ perl eg1-pl

=head2 COMPONENT DEFINITION - file eg1-defns

 my %hash =
 (
     Tr => { keep=>1,
             LocalName=>'tr',
             vars=>[qw( $arg1 $arg2 )],
           }
 );

 \%hash; # return ref to the hash


=head2 TEMPLATE BODY, XML - file eg1-xml

 <html>
 <head>
 <title>Example for Averse compiler
 </title>
 </head>
 <body>
 <p>Example table
 
 <table>
 <tr>
     <td> Value 1 is {+$arg1+} </td>
     <td> the second value is {+$arg2+} </td>
 </tr>
 </table>
 
 </p>
 </body>
 </html>


=head2 TEMPLATE CALLBACKS and main script - file eg1-pl

 #!/usr/bin/perl

 # this runs the compiled eg1 template
 # compile and run the template as follows

 #  $ perl averse-tcxml eg1-defns eg1-xml > eg1.do
 #  $ perl eg1-pl

 do "eg1.do";

 print Template::Template();

 use vars qw(@return);
 sub returning { push @return , @_ }

 sub Callback::Tr
 {
     local @return;
     foreach my $x (1..8)
     {
         returning Tr::Tr($x,$x*2);
     }
     @return;
 }
 

=head1 SIMPLE non-XML TEMPLATE LOOP with perl variables

For the purposes of illustration, this example is effectively identical to
the previous example, except that it uses non-xml parsing.  It also uses
perl variables within a simple loop, and the code is identical but for the
names.

This example is available with the distribution in the files

    eg2-defns  eg2-pl  eg1-xml
    
To create and run the compiled template, run the following commands inside
the top level directory of the distribution.

    $ perl averse-tcc eg2-defns eg1-xml > eg2.do
    $ perl eg2-pl


=head2 COMPONENT DEFINITION - file eg2-defns

 # Notes on the brackets in the markers.
 
 # (?=tag) : Look ahead means this marker matches a zero length string
 #           just before the component.  The effect is that the <tr>
 #           is included at the _beginning_ of the _next_ component.

 # (tag)   : The length of $1 is skipped.  The effect is that </tr> is 
 #           included at the _end_ of the _previous_ component.
 
 
 # No brackets (unused format in this example)
 # tag     : With no brackets, the text matched by tag would be the tag,
 #           and that text would _not_ be included in _any_ component.
 
 # The capturing ()'s must be at the start of the marker, but do not need
 # to be its entire length.  They can be used to skip just a portion of
 # the matched text.
 
 my %tags = ( Tr => { start => '(?=<tr>)',  # <- actually regular
                      end   => '(</tr>)',   # <-      expressions
                      vars  => [qw( $arg1 $arg2 )],
                    }
            );
 
 \%tags;


=head2 TEMPLATE BODY, (same file as above) - file eg1-xml

 <html>
 <head>
 <title>Example for Averse compiler
 </title>
 </head>
 <body>
 <p>Example table
 
 <table>
 <tr>
     <td> Value 1 is {+$arg1+} </td>
     <td> the second value is {+$arg2+} </td>
 </tr>
 </table>
 
 </p>
 </body>
 </html>


=head2 TEMPLATE CALLBACKS and main script - file eg2-pl

This is effectively identical to the above example, but for the name.

 #!/usr/bin/perl

 # this runs the compiled eg1 template
 # compile and run the template as follows

 #  $ perl averse-tcxml eg1-defns eg1-xml > eg1.do
 #  $ perl eg1-pl

 do "eg1.do";

 print Template::Template();

 use vars qw(@return);
 sub returning { push @return , @_ }

 sub Callback::Tr
 {
     local @return;
     foreach my $x (1..8)
     {
         returning Tr::Tr($x,$x*2);
     }
     @return;
 }
 

=head1 SCOPED VARIABLES VIA AN XML TAG 

This example illustates one possible technique to implement scoped
template variables via a general purpose xml tag - <var name="x"/>.

It also illustrates accessing the template component context, which it
uses to find the name of the variable.

Note: to embed a variable of this form within a tag, the tag would have to
be escaped.  In that case the tag could not also be targetted as a
component.  If you also wanted to target the container tag, then instead
of doing so, you would wrap a component tag around the escaped tag.

 e.g.    <input name='<var name="X">'>    NOT allowed

      &lt;input name='<var name="X">'&gt; allowed

 if you wanted to use <input> to identify a component, then instead
 
      <myInput>&lt;input name='<var name="X"/>'&gt;</myInput>

The following example is available with the distribution in the files

    egvars-defns egvars-pl  egvars-xml
    
To create and run the compiled template, run the following commands inside
the top level directory of the distribution.

    $ perl averse-tcxml egvars-defns egvars-xml > egvars.do egvars.do
    $ perl egvar-pl

Because of the simple xml, and the choice of tags that will not be kept
literally in the output, all we need to define is the list of tags to be
recognized.

=head2 COMPONENT (TAG) DEFINITION - file egvars-defns

 my @tags = (qw( list1 list2 var));
 \@tags;


=head2 TEMPLATE BODY - file egvars-xml

 <example-of-vars>
 <list1> <var name="x"/> <var name="y"/>
 <list2> <var name="x"/> <var name="y"/> <var name="z"/>
 </list2></list1>
 </example-of-vars>


=head2 TEMPLATE CALLBACKS and main script - file egvars-pl

 #!/usr/bin/perl
 
 # this examples shows scoped template variables where the variable
 # is accessed via a tag (in this example, <var name="x"/>
 
 # this runs the compiled egvars template
 # compile and run the template as follows
 
 #  $ perl averse-tcxml egvars-defns egvars-xml > egvars.do
 #  $ perl egvars-pl
 
 do "egvars.do";
 
 print Template::Template();
 
 # nice idiom
 use vars qw(@return);
 sub returning { push @return , @_ }
 
 # SUPPORT FOR SCOPED VARIABLES via a <var name="x"> tag
 # The name of the variable comes from the `name=' attribute of the 
 # tag, which is accessible to the callback via the context of the 
 # component.
 # The scope will come from perl local.  A routine that sets any 
 # variables must include `local %vars=%vars' to make this work.
 
 use vars qw(%vars);

 sub Callback::var 
 {
    my $ctx=shift;
    return $vars{ $ctx->{'Attributes'}{name} } ;
 }
 
 # Create some values for the variables.
 
 sub Callback::list1
 {
     local @return;
     local %vars=%vars;      # scope for the <var/> tag variables
 
     foreach ('A'..'H')
     {   
         $vars{'x'} = "X:$_";
         $vars{'y'} = "Y:$_";
 
         returning list1::list1();
     }
     @return;
 }
 
 sub Callback::list2
 {
     local @return;
     local %vars=%vars;      # scope for the <var/> tag variables
 
     foreach (1..4)
     {   
         $vars{'y'} = "y:$_";
         $vars{'z'} = "z:$_";
 
         returning list2::list2();
     }
     @return;
 }
 
 

=head1 XML EXAMPLE WITH CHILDREN IN A COMPONENT 

This example shows the use of children in components.  Child components
may not be the best way to handle this particular problem, but they are
used here because that is what the example is for.

This example also illustrates a non-default package for the compiled
component functions, and the use of xml name spaces.


=head2 CHILD COMPONENT DEFINITION

 my %components =
 (
    choose => 
    {   
        vars => [ qw( $part_name $part_number $sub_code )],

        case1_vars => [ qw( $part_number ) ],
        case2_vars => [ qw( $part_number $sub_code ) ],
        
        package => 'template::stuff' ,

        NamespaceURI => 'http://your.domain.com/my/xml/dtds',

        LocalName   => 'Choose-one', # i.e. <Choose-one> 

    }, # end define of choose

    case0 => { parent => 'choose' , LocalName => 'case-normal' } ,
    case1 => { parent => 'choose' } ,
    case2 => { parent => 'choose' } ,

 );

=head2 XML TEMPLATE BODY 

 <example>
 -------------------------------------
 <Choose-one xmlns='http://your.domain.com/my/xml/dtds'>
 Order options for {+$part_name+}.
 <case-normal>No restrictions for this part.
 </case-normal>
 <case1>Special order required for type number {+$part_number+}
 </case1>
 <case2>Part number {+$part_number+} is not available 
        with option {+$sub_code+}.
 </case2>
 -------------------------------------
 </Choose-one>
 </example>


=head2 CALLBACKS FOR THIS EXAMPLE

 # support a nice idiom
 use vars qw(@return);
 sub returning { push @return , @_ }

 # now provide the logic for the component

 sub Callback::choose
 {
    local @return;      # nice idiom

    foreach $part (@parts)   # please pretend this is defined
    {
        returning template::stuff::choose($part{'name'});

        if ( $part{'type'} == 0)
        {   returning template::stuff::case0();
        }

        elsif ( $part{'type'} == 1)
        {
            foreach $special (@{$part{'specials'}})
            {   returning template::stuff::case1($special{'number'});
            }

            foreach $sorry (@{$part{'sorrys'}})
            {   returning 
                  template::stuff::case2(@sorry{('number','code')});
            }
        }

        # careful, not all components should use the end_ sub

        returning template::stuff::end_choose();
    }
    @return; # DON'T FORGET THIS
 }


=head1 EXAMPLE OF SIMPLE VISUAL SUBROUTINE

This example defines a component that can be used at multiple locations in
the template - i.e. a visual subroutine.

This example does not include nesting of components in the subroutine.
Nested components that do not use subroutine specific parameters can be
included with no issues, they aren't shown simply for simplicity.

The caller's attributes could be used to specify the parameters for the
subroutine, but this example doesn't do that either, again for simplicity
in the example.

=head2 COMPONENT DEFINITION 

 my %tags = ( thesub  => { vars=>[qw($name $title)] },
              showboss    => {},
              showjanitor => {},
            );
 \%tags;

=head2 TEMPLATE BODY

 <example-of-visual-subroutine>
 <thesub>
    <table><tr><th>Name     </th><th>Title     </th></tr>
           <tr><td>{+$name+}</td><td>{+$title+}</td></tr>
    </table>
 </thesub>
 Info on the boss <br/> <showboss/> <br/>
 and the janitor is <br/> <showjanitor/> <br/>
 </example-of-visual-subroutine>


=head2 CALLBACKS 


 sub Callback::thesub {()} # return empty list at point of definition
 
 sub Callback::showboss
 {  return thesub::thesub('Mr Big Guy','Head Honcho');
 }

 sub Callback::showjanitor
 {  return thesub::thesub('Frank Handy','Lowly Pleb');
 }



=head1 EXAMPLE 2, SIMPLE VISUAL SUBROUTINE, direct call

This example is similar to the above, but the template directly calls
the subroutine with the desired parameters.

=head2 COMPONENT DEFINITION 

 my %tags = ( thesub  => { vars=>[qw($name $title)] },
              caller  => {},
            );
 \%tags;

=head2 TEMPLATE BODY

 <example-of-visual-subroutine>
 <thesub>
    <table><tr><th>Name     </th><th>Title     </th></tr>
           <tr><td>{+$name+}</td><td>{+$title+}</td></tr>
    </table>
 </thesub>
 Info on the boss <br/> <caller>{+
    thesub::thesub('Mr Big Guy','Head Honcho')+}</caller> <br/>
 and the janitor is <br/> <caller>{+
     thesub::thesub('Frank Handy','Lowly Pleb')+}</caller><br/>
 </example-of-visual-subroutine>


=head2 CALLBACKS 


 sub Callback::thesub {()} # return empty list at point of definition
 
 # simply return what ever the body of the component returns.

 sub Callback::caller { return caller::caller() } 


=head1 EXAMPLE, VISUAL SUBROUTINE, nested, using context

This example defines a component that can be used at multiple locations in
the template - i.e. a visual subroutine.

This example is more complex because it uses a loop within the subroutine.  

The loop callback must get the list from somewhere.  It gets it from the
context of its container.  To allow this, the subroutine definition and
the loop definition must be coordinated - the container must define the
variable used by the loop's callback.


=head2 COMPONENT DEFINITION 

 my %tags = ( thesub  => { vars=>[qw($items)] },
              eachitem=> { vars=>[qw($item)] },
              callit1 => {},
              callit2 => {},
            );
 \%tags;

=head2 TEMPLATE BODY

 <example-of-visual-subroutine>
 <thesub>
    <ol><eachitem><li>The item was {+ $item +}</li>
        </eachitem>
    </ol>
 </thesub>
 The first list goes here <callit1/>, <br/>
 and then the second list goes next<br/>
    <callit2/>
 </example-of-visual-subroutine>


=head2 CALLBACKS 


 sub Callback::thesub {()} # return empty list
 
 sub Callback::callit1
 {  
    my @items = qw(one two three);
    return thesub::thesub(\@items);
 }

 sub Callback::callit2
 {  
    my @items = qw(x y z);
    return thesub::thesub(\@items);
 }

 # this implements the logic required by the eachitem component.
 # We need a ref to an array.  The container of this component has
 # prepared for this by saving just such a reference.

 sub Callback::eachitem
 {   my ($context)=@_;
     local @return;

     my $items = ${$context->{Vars}{'$items'}}; # note ref of ref
     foreach my $item (@$items)
     {   returning eachitem::eachitem($item);
     }
     @return;
 }    

=head1 EXAMPLE, VISUAL SUBROUTINE, nested, not using context

This example defines a component that can be used at multiple locations in
the template - i.e. a visual subroutine.

This example is more complex because it uses a loop within the subroutine.  

However, in this example we will select different logic by overriding the
default name expected by the template.

In this case the logic knows what it must provide, and so no context must
be provided.  The context is implicit based on the original invocation.


=head2 COMPONENT DEFINITION 

 my %tags = ( thesub  => { },
              eachitem=> { vars=>[qw($item)] },
              callit1 => {},
              callit2 => {},
            );
 \%tags;

=head2 TEMPLATE BODY

 <example-of-visual-subroutine>
 <thesub>
    <ol><eachitem><li>The item was {+ $item +}</li>
        </eachitem>
    </ol>
 </thesub>
 The first list goes here <callit1/>, <br/>
 and then the second list goes next<br/>
    <callit2/>
 </example-of-visual-subroutine>


=head2 CALLBACKS 


 sub Callback::thesub {()} # return empty list
 
 sub eachitem_callback_1
 {   
     local @return;

     foreach my $item (qw(one two three)
     {   returning eachitem::eachitem($item);
     }
     @return;
 }    

 sub eachitem_callback_2
 {   
     local @return;
    
     open TTY , "+</dev/tty" or die "open TTY , +</dev/tty: $!";
     print TTY "Please enter a line containing a word:\n";
     while (<TTY>) 
     {  my ($item) = m/(\w+)/;
        returning eachitem::eachitem($item);
     }
     close TTY;
     @return;
 }    

 sub Callback::callit1
 {  
    local *Callback::eachitem = \&eachitem_callback_1;
    return thesub::thesub();
 }

 sub Callback::callit2
 {  
    local *Callback::eachitem = \&eachitem_callback_2;
    return thesub::thesub(\@items);
 }

